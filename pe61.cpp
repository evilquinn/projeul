/*
 * pe61.cpp
 *
 *  Created on: 13 Jun 2015
 *      Author: evilquinn
 */

#include "pe61.hpp"
#include <iostream>
#include <polygonal_numbers.hpp>

std::string& pe61::name() { return name_; }
void         pe61::run()
{
    /*
     *
     * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
     * numbers are all figurate (polygonal) numbers and are generated by the
     * following formulae:
     *   Triangle     P(3,n)=n(n+1)/2       1, 3, 6, 10, 15, ...
     *   Square       P(4,n)=n2             1, 4, 9, 16, 25, ...
     *   Pentagonal   P(5,n)=n(3n−1)/2      1, 5, 12, 22, 35, ...
     *   Hexagonal    P(6,n)=n(2n−1)        1, 6, 15, 28, 45, ...
     *   Heptagonal   P(7,n)=n(5n−3)/2      1, 7, 18, 34, 55, ...
     *   Octagonal    P(8,n)=n(3n−2)        1, 8, 21, 40, 65, ...
     *
     * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
     * interesting properties.
     *
     * 1. The set is cyclic, in that the last two digits of each number is the
     * first two digits of the next number (including the last number with the
     * first).
     * 2. Each polygonal type: triangle (P(3,127)=8128), square
     * (P(4,91)=8281),
     * and pentagonal (P(5,44)=2882), is represented by a different number in
     * the set.
     * 3. This is the only set of 4-digit numbers with this property.
     *
     * Find the sum of the only ordered set of six cyclic 4-digit numbers for
     * which each polygonal type: triangle, square, pentagonal, hexagonal,
     * heptagonal, and octagonal, is represented by a different number in the
     * set.
     *
     */

    struct data
    {
        size_t start;
        size_t end;
    } data[] = { {.start = 45, .end = 141 }, {.start = 32, .end = 100 },
                 {.start = 26, .end = 82 },  {.start = 23, .end = 71 },
                 {.start = 21, .end = 64 },  {.start = 19, .end = 59 } };

    polygonal_numbers list[] = {
        polygonal_numbers( data[0].end, polygonal_numbers::triangle ),
        polygonal_numbers( data[1].end, polygonal_numbers::square ),
        polygonal_numbers( data[2].end, polygonal_numbers::pentagonal ),
        polygonal_numbers( data[3].end, polygonal_numbers::hexagonal ),
        polygonal_numbers( data[4].end, polygonal_numbers::heptagonal ),
        polygonal_numbers( data[5].end, polygonal_numbers::octagonal ),
    };

    // to get set of 6 4-digit numbers, where any number could be from any
    // list, choose first number by arbitrarily starting at the beginning of
    // the first range, travelling all ranges.  To get a 'next' number,
    // traverse
    // all numbers in remaining lists looking for a cyclic potential.  Use
    // backtracking to attempt next numbers in the event that an avenue is
    // closed

    struct result
    {
        size_t num;
        size_t list;
    } results[] = { { 0, 10 }, { 0, 10 }, { 0, 10 },
                    { 0, 10 }, { 0, 10 }, { 0, 10 } };
    size_t pos            = 0;
    bool   backtracking   = false;
    size_t backtrack_next = 0;

    while ( pos < 6 )
    {
        size_t previous   = pos == 0 ? 0 : results[pos - 1].num;
        size_t low_bound  = pos == 0 ? 1000 : ( previous % 100 ) * 100;
        size_t high_bound = pos == 0 ? 10000 : low_bound + 100;
        bool   found_cand = false;
        for ( size_t l = backtracking ? results[pos].list : 0;
              // if we've backtracked, we'll start from last known point
              l < 6 /*lists*/;
              ++l )
        {
            bool list_used = false;
            for ( size_t i = 0; i <= pos; ++i )
            {
                if ( results[i].list == l )
                {
                    list_used = true;
                    break;
                }
            }
            if ( backtracking || !list_used )
            {
                for ( size_t i = data[l].start; i < data[l].end; ++i )
                {
                    size_t cand = list[l].get_term( i );
                    if ( cand < low_bound )
                    {
                        // not there yet
                        continue;
                    }
                    if ( backtracking )
                    {
                        if ( cand <= backtrack_next )
                        {
                            continue;
                        }
                    }
                    if ( cand >= high_bound )
                    {
                        // too far
                        break;
                    }

                    if ( pos == 5 )
                    {
                        // last contender, needs to be cyclic with first
                        if ( cand % 100 != ( results[0].num / 100 ) )
                        {
                            continue;
                        }
                    }

                    // get here, we have a contender
                    // pop it in, increment to next number
                    results[pos].num  = cand;
                    results[pos].list = l;

                    ++pos;
                    found_cand = true;
                    break;  // need to do more breakage here?
                }
            }

            backtracking = false;

            if ( found_cand )
            {
                break;
            }
        }

        if ( !found_cand )
        {
            // backtrack?
            --pos;
            backtracking   = true;
            backtrack_next = results[pos].num;
        }
    }

    size_t sum = results[0].num + results[1].num + results[2].num +
                 results[3].num + results[4].num + results[5].num;
    std::cout << name() << std::endl;
    std::cout << "got: " << sum << " from:\n"
              << results[0].num << "(" << results[0].list << ") "
              << results[1].num << "(" << results[1].list << ") "
              << results[2].num << "(" << results[2].list << ") "
              << results[3].num << "(" << results[3].list << ") "
              << results[4].num << "(" << results[4].list << ") "
              << results[5].num << "(" << results[5].list << ") "
              << std::endl;
}
